# SkipList-KVDatabase

## 背景

C++实现的一个K-V数据库组件（存储引擎）。包括增删改查，生成持久化文件、从文件恢复数据，对设置过期时间的数据进行管理。

## 应用

Redis：这是最著名的使用跳表的例子。Redis 是一个开源的高性能键值存储数据库，广泛用于缓存和消息队列等场景。在 Redis 中，跳表被用于实现有序集合（sorted sets）数据类型，这主要是因为跳表在处理有序数据时可以提供良好的性能，尤其是在插入、删除和搜索操作上。

LevelDB：LevelDB 是一个由 Google 开发的快速键值存储库，用于存储非结构化数据。它使用跳表作为其内存中的数据结构，以支持快速的写入操作。跳表在 LevelDB 中帮助实现高效的数据插入和排序。

LSM 树：在基于日志结构合并树（LSM Tree）的存储引擎中，跳表用于处理写入操作，因为它支持高效的插入性能，并能快速构建新的索引。

## 存储引擎简介

本项目是使用 C++ 开发、基于跳表实现的轻量级键值数据库。实现了插入数据、删除数据、查询数据、数据展示、生成持久化文件、恢复数据以及数据库大小显示等功能。

项目整体上拥有一个 skiplist.h 文件。

拥有两个核心类：

1. Node 类
2. SkipList 类

Node 类是存储引擎中用于存放实际数据的类，而 SkipList 则对外提供了组织，访问，操作 Node 类的功能。

## 跳表原理

跳表是一种概率性数据结构，基于多层有序链表，每一层都是下一层的一个子集。最底层包含所有元素，每个元素在上面一层出现的概率是 P（通常取 1/2）。

在跳表中，如果一个节点出现在较高层级，它必然出现在所有较低的层级。例如，一个节点若出现在第 3 层，那么它必定存在于第 2 层和第 1 层。

每个节点含有一个指针数组，数组下标 i 的元素指向第 i 层的下一个元素，以实现节点在不同层级跳转。

## Node 跳表节点类

存储键值、节点层数，返回键值以及设置节点值的接口

核心——指针数组next，数组中的每个指针指向节点在某个下标层级的后继节点。通过变更数组下标，便能够实现同一节点在不同层级之间的跳转功能。next[0] 指向该节点在第一层的下一个节点；next[1] 指向该节点在第二层的下一个节点；......

1——同一层级内节点的跳转：（假设第一层），通过迭代的方式：while (cur->next[0] != null) cur = cur->next;

2——不同层级内同一节点的跳转：Node<K,V>* node; 假设 node 是当前节点，Node<K,V>* cur = node->next[i];（修改 i 即可）

构造函数：参数为键、值和层级，返回节点 Node

## SkipList 类

属性

1. 头节点：作为跳表中所有节点组织的入口（类似于单链表，虚拟的头节点）
2. 最大层数：跳表中允许的最大层数
3. 当前层数：跳表当前的层数（当前最高层是第几层）
4. 节点数量：跳表当前的组织的所有节点总数
5. 文件读写：跳表生成持久化文件和读取持久化文件的写入器和读取器（ifstream、ofstream对象）

接口

【构造函数】：创建头节点，并初始化键值为默认值

【节点创建】：生成新的节点实例，调用 Node 构造函数，返回 Node*

【分配层级】：为每个新创建的节点分配一个合适的层数

使用 while (rand() % 2) 实现抛硬币效果实现随机层级增加，若是奇数则节点层数+1，直到偶数位置

为什么这种方法能有效维护跳表的索引。根据大数定律，当我们进行足够多的试验时，某个事件发生的实际频率会逐渐接近于该事件发生的理论概率。应用到跳表中，随着节点数量的增加，我们可以合理地假设每一层的节点数量大约是下一层的一半。这是因为每个节点在每一层出现的概率都是前一层的一半。因此，通过这种方法，跳表的索引能够得到有效的维护，保持其结构和效率。

一个节点出现在不同层级的概率呈逐层减半的趋势。例如，一个节点在第 1 层的出现概率是 100%，在第 2 层是 50%，在第 3 层是 25%，以此类推。

【查找】

从跳表最高层的首个结点开始（Node<K, V>* current = _header; current->next[i]，i开始为\_skip_list_level），向右遍历，如果当前节点的下一个节点的值小于待查找的值，则继续向右遍历（current = current->next[i];），如果当前节点的下一个节点的值大于待查找的值，下沉到下一层（i--）。重复过程，要么就找到了，要么到达最底层，此时检查当前结点的下一个节点值是否为待查找的值，若不是就没找到。

【插入】

参数 K，V，模板

插入是涉及多层的，必须更新每一层的索引结构，为此定义一个指针数组 update（大小为 \_max_level + 1，跳表所能允许的最大层级 + 1），记录各层待插入位置前的一个节点指针（前驱）。

从最高层向下搜索插入位置，找当前层中最接近且小于 key 的节点，保存每层中该节点，以便后续插入时更新指针；一旦大于则移动到下一层。反复，此时到达最底层，我们移动到下一节点（current = current->next[0];），开始准备插入，检查此节点的值：若已存在，取消插入return；若为空，意味着我们已经到达了层的终点，若不等于，则没有此值，这两种情况都要在update[0]和此节点之间插入：获取节点的层级高度，如果新节点的层级超出了跳表的当前最高层级，还要对所有新的更高层级待更新指针的节点，将头节点设置为它们的前驱节点（update[i] = \_header; i 从_skip_list_level + 1到random_level）并更新跳表的当前最高层级为新节点的层级。然后在各层插入新节点，同时更新前驱的next指针。

```c++
for (int i = 0; i <= random_level; i++) {
     // 新节点的下一个节点指向记录的前驱的下一个节点
     inserted_node->next[i] = update[i]->next[i];
     // 记录的前驱的下一个节点更新为新节点
     update[i]->next[i] = inserted_node;
}
```

【删除】

删除是涉及多层的，必须更新每一层的索引结构，为此定义一个指针数组 update（大小为 \_max_level + 1，跳表所能允许的最大层级 + 1），记录各层待删除位置前的一个节点指针（前驱）。

我们从最高层开始向下搜索待删除节点，寻找当前层中最接近且小于 key 的节点，记录每层待删除节点的前驱至update数组，若大于移动到下一层。此时到达最底层，我们移动到下一节点，判断节点的值是否为待删除的值，若是则逐层更新指针，移除节点。

```c++
update[i]->next[i] = current->next[i];
```

注意：

1——逐层删除节点时，若某层不存在此值，跳过

```c++
for (int i = 0; i <= _skip_list_level; i++) {
    if (update[i]->next[i] != current) break;
    update[i]->next[i] = current->next[i];
}
```

2——删除后循环判断，若最高层头节点的下一节点指针为空，减少跳表层级

```c++
_header->next[_skip_list_level] == NULL;
_skip_list_level--;
```

【落盘】

遍历跳表（只需要遍历最底层，Node<K, V>* node = _header->next[0];while (node != nullptr) {...}），写入到文件中，键值对的形式

【读取】

解析文件，插入键值对到跳表

【惰性删除、定期删除】

这是补充的功能，可以为键设置过期时间（TTL），并且在键过期后会通过两种方式自动删除它们：

Node类新增属性：long long expiration_time; // 过期的时间戳，单位：毫秒，-1表示永不过期

惰性删除：在访问某个键时（例如查找的过程访问了），检查该键是否已经过期，如果已经过期，则在访问时将其删除。缺点是可能会导致过期键在一段时间内仍然占用内存。

定期删除：周期性地（默认每秒10次）随机抽取一部分键（遍历跳表的底层，然后通过随机函数决定是否选择某个键），并检查它们的过期时间。如果发现某个键已经过期，则立即将其删除。这种方式可以保证过期键在一定时间内被及时删除，避免了过期键长时间占用内存。但定期删除会带来额外的CPU消耗，因为需要在每次抽取时检查键的过期时间。

可以在另一个线程中调用定期删除，注意加锁

存盘的时候要检查节点是否过期，对于未过期的节点，将其键、值和剩余的TTL时间（节点的剩余生存时间）写入文件

装载的时候根据剩余的TTL时间计算新的过期时间戳expiration_time

【压力测试】

8个线程随机生成键值对（键是随机数字，值是固定字符串）写入，每个线程写1百万/8个数据。

8个线程随机读（键是随机数字，所以可能找不到） 每个线程读1百万/8个数据次。



## 项目中文件

- test 文件夹包含 skiplist.h 使用跳表进行数据操作 test.cpp 和压力测试文件 test_stress.cpp；
- skiplist.h 跳表核心实现
- bin 生成可执行文件目录
- CMakeLists.txt 编译脚本
- store 存放数据落盘的文件
- stress_test_start.sh 压力测试脚本

## 使用示例

只需在自己的CPP文件中 include skiplist.h 就可以了

有关 CMake 使用详见👉[shayudiandian/Linux-CPP-development-environment: Linux C/C++ 开发环境教程](https://github.com/shayudiandian/Linux-CPP-development-environment)

```shell
cd SkipList-KVDatabase
mkdir build
cd build

cmake ..
make

./bin/test
```

一键执行压力测试性能

```shell
cd SkipList-KVDatabase
./stress_test_start.sh
```



## 优化

- 键值中的key用int型，若不是内置类型，需要自定义比较函数，如果修改key的类型，同时需要修改 SkipList.load_file 函数

- 加上一致性协议，例如 raft 就构成了分布式存储，再启动一个 http server 就可以对外提供分布式存储服务

